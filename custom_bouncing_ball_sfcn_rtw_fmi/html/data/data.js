var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"custom_bouncing_ball","ref":false,"files":[{"name":"custom_bouncing_ball_sf.c","type":"source","group":"model","path":"F:\\GitHubRepos\\bouncingball_fmu_example\\custom_bouncing_ball_sfcn_rtw_fmi","tag":"","groupDisplay":"Model files","code":"/*\r\n * custom_bouncing_ball_sf.c\r\n *\r\n * Code generation for model \"custom_bouncing_ball_sf\".\r\n *\r\n * Model version              : 1.4\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue May 17 16:32:33 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include <math.h>\r\n#include \"custom_bouncing_ball_sf.h\"\r\n#include \"custom_bouncing_ball_sf_private.h\"\r\n#include \"simstruc.h\"\r\n#include \"fixedpoint.h\"\r\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\r\n\r\nextern void *custom_bouncing_ball_malloc(SimStruct *S);\r\n\r\n#endif\r\n\r\n#ifndef __RTW_UTFREE__\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\nextern void * utMalloc(size_t);\r\nextern void utFree(void *);\r\n\r\n#endif\r\n#endif                                 /* #ifndef __RTW_UTFREE__ */\r\n\r\n#if defined(MATLAB_MEX_FILE)\r\n#include \"rt_nonfinite.c\"\r\n#endif\r\n\r\nstatic const char_T *RT_MEMORY_ALLOCATION_ERROR =\r\n  \"memory allocation error in generated S-Function\";\r\n\r\n/* System initialize for root system: '<Root>' */\r\n#define MDL_INITIALIZE_CONDITIONS\r\n\r\nstatic void mdlInitializeConditions(SimStruct *S)\r\n{\r\n  if (ssIsFirstInitCond(S)) {\r\n    P_custom_bouncing_ball_T *_rtP;\r\n    X_custom_bouncing_ball_T *_rtX;\r\n    _rtX = ((X_custom_bouncing_ball_T *) ssGetContStates(S));\r\n    _rtP = ((P_custom_bouncing_ball_T *) ssGetLocalDefaultParam(S));\r\n\r\n    /* InitializeConditions for Memory: '<Root>/Memory' */\r\n    ((real_T *)ssGetDWork(S, 0))[0] = _rtP->Memory_InitialCondition;\r\n\r\n    /* InitializeConditions for SecondOrderIntegrator: '<Root>/Integrator, Second-Order' */\r\n    _rtX->IntegratorSecondOrder_CSTATE[0] = _rtP->IntegratorSecondOrder_ICX;\r\n    ((int_T *)ssGetDWork(S, 1))[0] = 0;\r\n    ((boolean_T *)ssGetDWork(S, 3))[0] = true;\r\n  } else {\r\n    P_custom_bouncing_ball_T *_rtP;\r\n    X_custom_bouncing_ball_T *_rtX;\r\n    _rtX = ((X_custom_bouncing_ball_T *) ssGetContStates(S));\r\n    _rtP = ((P_custom_bouncing_ball_T *) ssGetLocalDefaultParam(S));\r\n\r\n    /* InitializeConditions for Memory: '<Root>/Memory' */\r\n    ((real_T *)ssGetDWork(S, 0))[0] = _rtP->Memory_InitialCondition;\r\n\r\n    /* InitializeConditions for SecondOrderIntegrator: '<Root>/Integrator, Second-Order' */\r\n    _rtX->IntegratorSecondOrder_CSTATE[0] = _rtP->IntegratorSecondOrder_ICX;\r\n    ((int_T *)ssGetDWork(S, 1))[0] = 0;\r\n    ((boolean_T *)ssGetDWork(S, 3))[0] = true;\r\n  }\r\n}\r\n\r\n/* Start for root system: '<Root>' */\r\n#define MDL_START\r\n\r\nstatic void mdlStart(SimStruct *S)\r\n{\r\n  /* instance underlying S-Function data */\r\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\r\n#if defined(MATLAB_MEX_FILE)\r\n\r\n  /* non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n  /* Check for invalid switching between solver types */\r\n  if (ssIsVariableStepSolver(S)) {\r\n    ssSetErrorStatus(S, \"This Simulink Coder generated \"\r\n                     \"S-Function cannot be used in a simulation with \"\r\n                     \"a solver type of variable-step \"\r\n                     \"because this S-Function was created from a model with \"\r\n                     \"solver type of fixed-step and it has continuous time blocks. \"\r\n                     \"See the Solver page of the simulation parameters dialog.\");\r\n    return;\r\n  }\r\n\r\n  if (ssGetSolverMode(S) == SOLVER_MODE_MULTITASKING) {\r\n    ssSetErrorStatus(S, \"This Simulink Coder generated \"\r\n                     \"S-Function cannot be used in a simulation with \"\r\n                     \"solver mode set to auto or multitasking \"\r\n                     \"because this S-Function was created from a model with \"\r\n                     \"solver mode set to singletasking. \"\r\n                     \"See the Solver page of the simulation parameters dialog.\");\r\n    return;\r\n  }\r\n\r\n#endif\r\n\r\n  custom_bouncing_ball_malloc(S);\r\n  if (ssGetErrorStatus(S) != (NULL) ) {\r\n    return;\r\n  }\r\n\r\n#endif\r\n\r\n  {\r\n    /* Start for InitialCondition: '<Root>/Initial Velocity ' */\r\n    ((boolean_T *)ssGetDWork(S, 2))[0] = true;\r\n  }\r\n}\r\n\r\n/* Outputs for root system: '<Root>' */\r\nstatic void mdlOutputs(SimStruct *S, int_T tid)\r\n{\r\n  B_custom_bouncing_ball_T *_rtB;\r\n  X_custom_bouncing_ball_T *_rtX;\r\n  _rtX = ((X_custom_bouncing_ball_T *) ssGetContStates(S));\r\n  _rtB = ((B_custom_bouncing_ball_T *) ssGetLocalBlockIO(S));\r\n  if (ssIsSampleHit(S, 1, 0)) {\r\n    /* InitialCondition: '<Root>/Initial Velocity ' */\r\n    if (((boolean_T *)ssGetDWork(S, 2))[0]) {\r\n      ((boolean_T *)ssGetDWork(S, 2))[0] = false;\r\n\r\n      /* InitialCondition: '<Root>/Initial Velocity ' */\r\n      _rtB->InitialVelocity = (*(real_T *)(mxGetData(v(S))));\r\n    } else {\r\n      /* InitialCondition: '<Root>/Initial Velocity ' incorporates:\r\n       *  Gain: '<Root>/Gain'\r\n       *  Memory: '<Root>/Memory'\r\n       */\r\n      _rtB->InitialVelocity = (*(real_T *)(mxGetData(r(S)))) * ((real_T *)\r\n        ssGetDWork(S, 0))[0];\r\n    }\r\n\r\n    /* End of InitialCondition: '<Root>/Initial Velocity ' */\r\n  }\r\n\r\n  if (1) {\r\n    /* SecondOrderIntegrator: '<Root>/Integrator, Second-Order' */\r\n    if (((boolean_T *)ssGetDWork(S, 3))[0]) {\r\n      _rtX->IntegratorSecondOrder_CSTATE[1] = _rtB->InitialVelocity;\r\n    }\r\n\r\n    /* SecondOrderIntegrator: '<Root>/Integrator, Second-Order' */\r\n    _rtB->IntegratorSecondOrder_o2 = _rtX->IntegratorSecondOrder_CSTATE[1];\r\n\r\n    /* Outport: '<Root>/Position' incorporates:\r\n     *  SecondOrderIntegrator: '<Root>/Integrator, Second-Order'\r\n     */\r\n    ((real_T *)ssGetOutputPortSignal(S, 0))[0] =\r\n      _rtX->IntegratorSecondOrder_CSTATE[0];\r\n\r\n    /* Outport: '<Root>/Velocity' */\r\n    ((real_T *)ssGetOutputPortSignal(S, 1))[0] = _rtB->IntegratorSecondOrder_o2;\r\n  }\r\n\r\n  UNUSED_PARAMETER(tid);\r\n}\r\n\r\n/* Update for root system: '<Root>' */\r\n#define MDL_UPDATE\r\n\r\nstatic void mdlUpdate(SimStruct *S, int_T tid)\r\n{\r\n  B_custom_bouncing_ball_T *_rtB;\r\n  _rtB = ((B_custom_bouncing_ball_T *) ssGetLocalBlockIO(S));\r\n  if (ssIsSampleHit(S, 1, 0)) {\r\n    /* Update for Memory: '<Root>/Memory' */\r\n    ((real_T *)ssGetDWork(S, 0))[0] = _rtB->IntegratorSecondOrder_o2;\r\n  }\r\n\r\n  /* Update for SecondOrderIntegrator: '<Root>/Integrator, Second-Order' */\r\n  ((boolean_T *)ssGetDWork(S, 3))[0] = ((!1) && ((boolean_T *)ssGetDWork(S, 3))\r\n    [0]);\r\n  UNUSED_PARAMETER(tid);\r\n}\r\n\r\n/* Derivatives for root system: '<Root>' */\r\n#define MDL_DERIVATIVES\r\n\r\nstatic void mdlDerivatives(SimStruct *S)\r\n{\r\n  XDot_custom_bouncing_ball_T *_rtXdot;\r\n  X_custom_bouncing_ball_T *_rtX;\r\n  _rtXdot = ((XDot_custom_bouncing_ball_T *) ssGetdX(S));\r\n  _rtX = ((X_custom_bouncing_ball_T *) ssGetContStates(S));\r\n\r\n  /* Derivatives for SecondOrderIntegrator: '<Root>/Integrator, Second-Order' incorporates:\r\n   *  Constant: '<Root>/Constant'\r\n   */\r\n  if (((int_T *)ssGetDWork(S, 1))[0] == 0) {\r\n    _rtXdot->IntegratorSecondOrder_CSTATE[0] =\r\n      _rtX->IntegratorSecondOrder_CSTATE[1];\r\n    _rtXdot->IntegratorSecondOrder_CSTATE[1] = (*(real_T *)(mxGetData(g(S))));\r\n  }\r\n\r\n  /* End of Derivatives for SecondOrderIntegrator: '<Root>/Integrator, Second-Order' */\r\n}\r\n\r\n/* Termination for root system: '<Root>' */\r\nstatic void mdlTerminate(SimStruct *S)\r\n{\r\n\r\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\r\n\r\n  if (ssGetUserData(S) != (NULL) ) {\r\n    rt_FREE(ssGetLocalBlockIO(S));\r\n  }\r\n\r\n  rt_FREE(ssGetUserData(S));\r\n\r\n#endif\r\n\r\n}\r\n\r\n/* This function checks the attributes of tunable parameters. */\r\n#define MDL_CHECK_PARAMETERS\r\n#if defined(MDL_CHECK_PARAMETERS) && defined(MATLAB_MEX_FILE)\r\n\r\nstatic void mdlCheckParameters(SimStruct *S)\r\n{\r\n  /* Parameter check for 'g' */\r\n  if (mxIsComplex(ssGetSFcnParam(S, 0))) {\r\n    ssSetErrorStatus(S,\"Parameter 'g' has to be a non complex array.\");\r\n    return;\r\n  }\r\n\r\n  if (!mxIsDouble(ssGetSFcnParam(S, 0))) {\r\n    ssSetErrorStatus(S,\"Parameter 'g' has to be a double array.\");\r\n    return;\r\n  }\r\n\r\n  if ((mxGetNumberOfDimensions(ssGetSFcnParam(S, 0)) != 2) ||\r\n      (mxGetDimensions(ssGetSFcnParam(S, 0))[0] != 1) ||\r\n      (mxGetDimensions(ssGetSFcnParam(S, 0))[1] != 1) ) {\r\n    ssSetErrorStatus(S,\"Parameter 'g' has to be a [1x1] array.\");\r\n    return;\r\n  }\r\n\r\n  /* Parameter check for 'r' */\r\n  if (mxIsComplex(ssGetSFcnParam(S, 1))) {\r\n    ssSetErrorStatus(S,\"Parameter 'r' has to be a non complex array.\");\r\n    return;\r\n  }\r\n\r\n  if (!mxIsDouble(ssGetSFcnParam(S, 1))) {\r\n    ssSetErrorStatus(S,\"Parameter 'r' has to be a double array.\");\r\n    return;\r\n  }\r\n\r\n  if ((mxGetNumberOfDimensions(ssGetSFcnParam(S, 1)) != 2) ||\r\n      (mxGetDimensions(ssGetSFcnParam(S, 1))[0] != 1) ||\r\n      (mxGetDimensions(ssGetSFcnParam(S, 1))[1] != 1) ) {\r\n    ssSetErrorStatus(S,\"Parameter 'r' has to be a [1x1] array.\");\r\n    return;\r\n  }\r\n\r\n  /* Parameter check for 'v' */\r\n  if (mxIsComplex(ssGetSFcnParam(S, 2))) {\r\n    ssSetErrorStatus(S,\"Parameter 'v' has to be a non complex array.\");\r\n    return;\r\n  }\r\n\r\n  if (!mxIsDouble(ssGetSFcnParam(S, 2))) {\r\n    ssSetErrorStatus(S,\"Parameter 'v' has to be a double array.\");\r\n    return;\r\n  }\r\n\r\n  if ((mxGetNumberOfDimensions(ssGetSFcnParam(S, 2)) != 2) ||\r\n      (mxGetDimensions(ssGetSFcnParam(S, 2))[0] != 1) ||\r\n      (mxGetDimensions(ssGetSFcnParam(S, 2))[1] != 1) ) {\r\n    ssSetErrorStatus(S,\"Parameter 'v' has to be a [1x1] array.\");\r\n    return;\r\n  }\r\n}\r\n\r\n#endif                                 /* MDL_CHECK_PARAMETERS */\r\n\r\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\r\n#include \"custom_bouncing_ball_mid.h\"\r\n#endif\r\n\r\n/* Function to initialize sizes. */\r\nstatic void mdlInitializeSizes(SimStruct *S)\r\n{\r\n  ssSetNumSampleTimes(S, 2);           /* Number of sample times */\r\n  ssSetNumContStates(S, 2);            /* Number of continuous states */\r\n  ssSetNumPeriodicContStates(S, 0);   /* Number of periodic continuous states */\r\n  ssSetNumNonsampledZCs(S, 0);         /* Number of nonsampled ZCs */\r\n\r\n  /* Number of output ports */\r\n  if (!ssSetNumOutputPorts(S, 2))\r\n    return;\r\n\r\n  /* outport number: 0 */\r\n  if (!ssSetOutputPortVectorDimension(S, 0, 1))\r\n    return;\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetOutputPortDataType(S, 0, SS_DOUBLE);\r\n  }\r\n\r\n  ssSetOutputPortSampleTime(S, 0, 0.0);\r\n  ssSetOutputPortOffsetTime(S, 0, 0.0);\r\n  ssSetOutputPortOptimOpts(S, 0, SS_REUSABLE_AND_LOCAL);\r\n\r\n  /* outport number: 1 */\r\n  if (!ssSetOutputPortVectorDimension(S, 1, 1))\r\n    return;\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetOutputPortDataType(S, 1, SS_DOUBLE);\r\n  }\r\n\r\n  ssSetOutputPortSampleTime(S, 1, 0.0);\r\n  ssSetOutputPortOffsetTime(S, 1, 0.0);\r\n  ssSetOutputPortOptimOpts(S, 1, SS_REUSABLE_AND_LOCAL);\r\n\r\n  /* Number of input ports */\r\n  if (!ssSetNumInputPorts(S, 0))\r\n    return;\r\n  ssSetRTWGeneratedSFcn(S, 1);         /* Generated S-function */\r\n\r\n  /* DWork */\r\n  if (!ssSetNumDWork(S, 4)) {\r\n    return;\r\n  }\r\n\r\n  /* '<Root>/Memory': PreviousInput */\r\n  ssSetDWorkName(S, 0, \"DWORK0\");\r\n  ssSetDWorkWidth(S, 0, 1);\r\n\r\n  /* '<Root>/Integrator, Second-Order': MODE */\r\n  ssSetDWorkName(S, 1, \"DWORK1\");\r\n  ssSetDWorkWidth(S, 1, 1);\r\n  ssSetDWorkDataType(S, 1, SS_INTEGER);\r\n\r\n  /* '<Root>/Initial Velocity ': FirstOutputTime */\r\n  ssSetDWorkName(S, 2, \"DWORK2\");\r\n  ssSetDWorkWidth(S, 2, 1);\r\n  ssSetDWorkDataType(S, 2, SS_BOOLEAN);\r\n\r\n  /* '<Root>/Integrator, Second-Order': DWORK1 */\r\n  ssSetDWorkName(S, 3, \"DWORK3\");\r\n  ssSetDWorkWidth(S, 3, 1);\r\n  ssSetDWorkDataType(S, 3, SS_BOOLEAN);\r\n\r\n  /* Tunable Parameters */\r\n  ssSetNumSFcnParams(S, 3);\r\n\r\n  /* Number of expected parameters */\r\n#if defined(MATLAB_MEX_FILE)\r\n\r\n  if (ssGetNumSFcnParams(S) == ssGetSFcnParamsCount(S)) {\r\n\r\n#if defined(MDL_CHECK_PARAMETERS)\r\n\r\n    mdlCheckParameters(S);\r\n\r\n#endif                                 /* MDL_CHECK_PARAMETERS */\r\n\r\n    if (ssGetErrorStatus(S) != (NULL) ) {\r\n      return;\r\n    }\r\n  } else {\r\n    return;                /* Parameter mismatch will be reported by Simulink */\r\n  }\r\n\r\n#endif                                 /* MATLAB_MEX_FILE */\r\n\r\n  /* Options */\r\n  ssSetOptions(S, (SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE |\r\n                   SS_OPTION_PORT_SAMPLE_TIMES_ASSIGNED ));\r\n\r\n#if SS_SFCN_FOR_SIM\r\n\r\n  {\r\n    ssSupportsMultipleExecInstances(S, true);\r\n    ssHasStateInsideForEachSS(S, false);\r\n  }\r\n\r\n#endif\r\n\r\n}\r\n\r\n/* Function to initialize sample times. */\r\nstatic void mdlInitializeSampleTimes(SimStruct *S)\r\n{\r\n  /* task periods */\r\n  ssSetSampleTime(S, 0, 0.0);\r\n  ssSetSampleTime(S, 1, 0.2);\r\n\r\n  /* task offsets */\r\n  ssSetOffsetTime(S, 0, 0.0);\r\n  ssSetOffsetTime(S, 1, 0.0);\r\n}\r\n\r\n#if defined(MATLAB_MEX_FILE)\r\n#include \"fixedpoint.c\"\r\n#include \"simulink.c\"\r\n#else\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME                custom_bouncing_ball_sf\r\n#include \"cg_sfun.h\"\r\n#endif                                 /* defined(MATLAB_MEX_FILE) */\r\n"},{"name":"custom_bouncing_ball_sf.h","type":"header","group":"model","path":"F:\\GitHubRepos\\bouncingball_fmu_example\\custom_bouncing_ball_sfcn_rtw_fmi","tag":"","groupDisplay":"Model files","code":"/*\r\n * custom_bouncing_ball_sf.h\r\n *\r\n * Code generation for model \"custom_bouncing_ball_sf\".\r\n *\r\n * Model version              : 1.4\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue May 17 16:32:33 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_custom_bouncing_ball_sf_h_\r\n#define RTW_HEADER_custom_bouncing_ball_sf_h_\r\n#include <string.h>\r\n#include <stddef.h>\r\n#ifndef custom_bouncing_ball_sf_COMMON_INCLUDES_\r\n#define custom_bouncing_ball_sf_COMMON_INCLUDES_\r\n#include <stdlib.h>\r\n#define S_FUNCTION_NAME                custom_bouncing_ball_sf\r\n#define S_FUNCTION_LEVEL               2\r\n#ifndef RTW_GENERATED_S_FUNCTION\r\n#define RTW_GENERATED_S_FUNCTION\r\n#endif\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"simstruc.h\"\r\n#include \"fixedpoint.h\"\r\n#if !defined(MATLAB_MEX_FILE)\r\n#include \"rt_matrx.h\"\r\n#endif\r\n\r\n#if !defined(RTW_SFUNCTION_DEFINES)\r\n#define RTW_SFUNCTION_DEFINES\r\n\r\ntypedef struct {\r\n  void *blockIO;\r\n  void *defaultParam;\r\n  void *nonContDerivSig;\r\n} LocalS;\r\n\r\n#define ssSetLocalBlockIO(S, io)       ((LocalS *)ssGetUserData(S))->blockIO = ((void *)(io))\r\n#define ssGetLocalBlockIO(S)           ((LocalS *)ssGetUserData(S))->blockIO\r\n#define ssSetLocalDefaultParam(S, paramVector) ((LocalS *)ssGetUserData(S))->defaultParam = (paramVector)\r\n#define ssGetLocalDefaultParam(S)      ((LocalS *)ssGetUserData(S))->defaultParam\r\n#define ssSetLocalNonContDerivSig(S, pSig) ((LocalS *)ssGetUserData(S))->nonContDerivSig = (pSig)\r\n#define ssGetLocalNonContDerivSig(S)   ((LocalS *)ssGetUserData(S))->nonContDerivSig\r\n#endif\r\n#endif                            /* custom_bouncing_ball_sf_COMMON_INCLUDES_ */\r\n\r\n#include \"custom_bouncing_ball_sf_types.h\"\r\n\r\n/* Shared type includes */\r\n#include \"multiword_types.h\"\r\n#include \"rtGetNaN.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"rt_defines.h\"\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T InitialVelocity;              /* '<Root>/Initial Velocity ' */\r\n  real_T IntegratorSecondOrder_o2;     /* '<Root>/Integrator, Second-Order' */\r\n} B_custom_bouncing_ball_T;\r\n\r\n/* Continuous states (default storage) */\r\ntypedef struct {\r\n  real_T IntegratorSecondOrder_CSTATE[2];/* '<Root>/Integrator, Second-Order' */\r\n} X_custom_bouncing_ball_T;\r\n\r\n/* State derivatives (default storage) */\r\ntypedef struct {\r\n  real_T IntegratorSecondOrder_CSTATE[2];/* '<Root>/Integrator, Second-Order' */\r\n} XDot_custom_bouncing_ball_T;\r\n\r\n/* State disabled  */\r\ntypedef struct {\r\n  boolean_T IntegratorSecondOrder_CSTATE[2];/* '<Root>/Integrator, Second-Order' */\r\n} XDis_custom_bouncing_ball_T;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real_T *Position;                    /* '<Root>/Position' */\r\n  real_T *Velocity;                    /* '<Root>/Velocity' */\r\n} ExtY_custom_bouncing_ball_T;\r\n\r\n/* Parameters (default storage) */\r\nstruct P_custom_bouncing_ball_T_ {\r\n  real_T g;                            /* Variable: g\r\n                                        * Referenced by: '<Root>/Constant'\r\n                                        */\r\n  real_T r;                            /* Variable: r\r\n                                        * Referenced by: '<Root>/Gain'\r\n                                        */\r\n  real_T v;                            /* Variable: v\r\n                                        * Referenced by: '<Root>/Initial Velocity '\r\n                                        */\r\n  real_T Memory_InitialCondition;      /* Expression: 0\r\n                                        * Referenced by: '<Root>/Memory'\r\n                                        */\r\n  real_T IntegratorSecondOrder_ICX;    /* Expression: 0.0\r\n                                        * Referenced by: '<Root>/Integrator, Second-Order'\r\n                                        */\r\n};\r\n\r\nextern P_custom_bouncing_ball_T custom_bouncing_ball_DefaultP;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'custom_bouncing_ball_sf'\r\n */\r\n#endif                               /* RTW_HEADER_custom_bouncing_ball_sf_h_ */\r\n"},{"name":"custom_bouncing_ball_sf_private.h","type":"header","group":"model","path":"F:\\GitHubRepos\\bouncingball_fmu_example\\custom_bouncing_ball_sfcn_rtw_fmi","tag":"","groupDisplay":"Model files","code":"/*\r\n * custom_bouncing_ball_sf_private.h\r\n *\r\n * Code generation for model \"custom_bouncing_ball_sf\".\r\n *\r\n * Model version              : 1.4\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue May 17 16:32:33 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_custom_bouncing_ball_sf_private_h_\r\n#define RTW_HEADER_custom_bouncing_ball_sf_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n#if !defined(ss_VALIDATE_MEMORY)\r\n#define ss_VALIDATE_MEMORY(S, ptr)     if(!(ptr)) {\\\r\n ssSetErrorStatus(S, RT_MEMORY_ALLOCATION_ERROR);\\\r\n }\r\n#endif\r\n\r\n#if !defined(rt_FREE)\r\n#if !defined(_WIN32)\r\n#define rt_FREE(ptr)                   if((ptr) != (NULL)) {\\\r\n free((ptr));\\\r\n (ptr) = (NULL);\\\r\n }\r\n#else\r\n\r\n/* Visual and other windows compilers declare free without const */\r\n#define rt_FREE(ptr)                   if((ptr) != (NULL)) {\\\r\n free((void *)(ptr));\\\r\n (ptr) = (NULL);\\\r\n }\r\n#endif\r\n#endif\r\n\r\n/*\r\n * Tunable Parameters\r\n *\r\n * Note: Tunable parameters with Auto storage class are treated as S-Function\r\n * parameters in the generated S-Function Target.  The generated\r\n * s-function will declare them as parameters and verify correct data\r\n * types/sizes are maintained.  The parameters are propagated to nested\r\n * non-inlined S-Functions\r\n *\r\n */\r\n#if !defined(RTW_GENERATED_SFCN_TUNABLE_PRMS_custom_bouncing_ball_sf)\r\n#define g(S)                           _ssGetSFcnParam(S,0)\r\n#define r(S)                           _ssGetSFcnParam(S,1)\r\n#define v(S)                           _ssGetSFcnParam(S,2)\r\n#endif             /* RTW_GENERATED_SFCN_TUNABLE_PRMS_custom_bouncing_ball_sf */\r\n\r\n#if defined(MULTITASKING)\r\n#  error Model (custom_bouncing_ball_sf) was built in \\\r\nSingleTasking solver mode, however the MULTITASKING define is \\\r\npresent. If you have multitasking (e.g. -DMT or -DMULTITASKING) \\\r\ndefined on the Code Generation page of Simulation parameter dialog, please \\\r\nremove it and on the Solver page, select solver mode \\\r\nMultiTasking. If the Simulation parameter dialog is configured \\\r\ncorrectly, please verify that your template makefile is \\\r\nconfigured correctly.\r\n#endif\r\n#endif                       /* RTW_HEADER_custom_bouncing_ball_sf_private_h_ */\r\n"},{"name":"custom_bouncing_ball_sf_types.h","type":"header","group":"model","path":"F:\\GitHubRepos\\bouncingball_fmu_example\\custom_bouncing_ball_sfcn_rtw_fmi","tag":"","groupDisplay":"Model files","code":"/*\r\n * custom_bouncing_ball_sf_types.h\r\n *\r\n * Code generation for model \"custom_bouncing_ball_sf\".\r\n *\r\n * Model version              : 1.4\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue May 17 16:32:33 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_custom_bouncing_ball_sf_types_h_\r\n#define RTW_HEADER_custom_bouncing_ball_sf_types_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n\r\n/* Model Code Variants */\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_custom_bouncing_ball_T_ P_custom_bouncing_ball_T;\r\n\r\n#endif                         /* RTW_HEADER_custom_bouncing_ball_sf_types_h_ */\r\n"},{"name":"custom_bouncing_ball_sf_data.c","type":"source","group":"data","path":"F:\\GitHubRepos\\bouncingball_fmu_example\\custom_bouncing_ball_sfcn_rtw_fmi","tag":"","groupDisplay":"Data files","code":"/*\r\n * custom_bouncing_ball_sf_data.c\r\n *\r\n * Code generation for model \"custom_bouncing_ball_sf\".\r\n *\r\n * Model version              : 1.4\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue May 17 16:32:33 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"custom_bouncing_ball_sf.h\"\r\n#include \"custom_bouncing_ball_sf_private.h\"\r\n\r\n/* Block parameters (default storage) */\r\nP_custom_bouncing_ball_T custom_bouncing_ball_DefaultP = {\r\n  /* Variable: g\r\n   * Referenced by: '<Root>/Constant'\r\n   */\r\n  -9.81,\r\n\r\n  /* Variable: r\r\n   * Referenced by: '<Root>/Gain'\r\n   */\r\n  0.8,\r\n\r\n  /* Variable: v\r\n   * Referenced by: '<Root>/Initial Velocity '\r\n   */\r\n  15.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/Memory'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0.0\r\n   * Referenced by: '<Root>/Integrator, Second-Order'\r\n   */\r\n  0.0\r\n};\r\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\bouncingball_fmu_example\\custom_bouncing_ball_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"/*\r\n * multiword_types.h\r\n *\r\n * Code generation for model \"custom_bouncing_ball_sf\".\r\n *\r\n * Model version              : 1.4\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue May 17 16:32:33 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * Definitions supporting external data access\r\n */\r\ntypedef int64_T chunk_T;\r\ntypedef uint64_T uchunk_T;\r\n\r\n/*\r\n * MultiWord supporting definitions\r\n */\r\ntypedef long long longlong_T;\r\n\r\n/*\r\n * MultiWord types\r\n */\r\ntypedef struct {\r\n  uint64_T chunks[2];\r\n} int128m_T;\r\n\r\ntypedef struct {\r\n  int128m_T re;\r\n  int128m_T im;\r\n} cint128m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[2];\r\n} uint128m_T;\r\n\r\ntypedef struct {\r\n  uint128m_T re;\r\n  uint128m_T im;\r\n} cuint128m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[3];\r\n} int192m_T;\r\n\r\ntypedef struct {\r\n  int192m_T re;\r\n  int192m_T im;\r\n} cint192m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[3];\r\n} uint192m_T;\r\n\r\ntypedef struct {\r\n  uint192m_T re;\r\n  uint192m_T im;\r\n} cuint192m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[4];\r\n} int256m_T;\r\n\r\ntypedef struct {\r\n  int256m_T re;\r\n  int256m_T im;\r\n} cint256m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[4];\r\n} uint256m_T;\r\n\r\ntypedef struct {\r\n  uint256m_T re;\r\n  uint256m_T im;\r\n} cuint256m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[5];\r\n} int320m_T;\r\n\r\ntypedef struct {\r\n  int320m_T re;\r\n  int320m_T im;\r\n} cint320m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[5];\r\n} uint320m_T;\r\n\r\ntypedef struct {\r\n  uint320m_T re;\r\n  uint320m_T im;\r\n} cuint320m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[6];\r\n} int384m_T;\r\n\r\ntypedef struct {\r\n  int384m_T re;\r\n  int384m_T im;\r\n} cint384m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[6];\r\n} uint384m_T;\r\n\r\ntypedef struct {\r\n  uint384m_T re;\r\n  uint384m_T im;\r\n} cuint384m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[7];\r\n} int448m_T;\r\n\r\ntypedef struct {\r\n  int448m_T re;\r\n  int448m_T im;\r\n} cint448m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[7];\r\n} uint448m_T;\r\n\r\ntypedef struct {\r\n  uint448m_T re;\r\n  uint448m_T im;\r\n} cuint448m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[8];\r\n} int512m_T;\r\n\r\ntypedef struct {\r\n  int512m_T re;\r\n  int512m_T im;\r\n} cint512m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[8];\r\n} uint512m_T;\r\n\r\ntypedef struct {\r\n  uint512m_T re;\r\n  uint512m_T im;\r\n} cuint512m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[9];\r\n} int576m_T;\r\n\r\ntypedef struct {\r\n  int576m_T re;\r\n  int576m_T im;\r\n} cint576m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[9];\r\n} uint576m_T;\r\n\r\ntypedef struct {\r\n  uint576m_T re;\r\n  uint576m_T im;\r\n} cuint576m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[10];\r\n} int640m_T;\r\n\r\ntypedef struct {\r\n  int640m_T re;\r\n  int640m_T im;\r\n} cint640m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[10];\r\n} uint640m_T;\r\n\r\ntypedef struct {\r\n  uint640m_T re;\r\n  uint640m_T im;\r\n} cuint640m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[11];\r\n} int704m_T;\r\n\r\ntypedef struct {\r\n  int704m_T re;\r\n  int704m_T im;\r\n} cint704m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[11];\r\n} uint704m_T;\r\n\r\ntypedef struct {\r\n  uint704m_T re;\r\n  uint704m_T im;\r\n} cuint704m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[12];\r\n} int768m_T;\r\n\r\ntypedef struct {\r\n  int768m_T re;\r\n  int768m_T im;\r\n} cint768m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[12];\r\n} uint768m_T;\r\n\r\ntypedef struct {\r\n  uint768m_T re;\r\n  uint768m_T im;\r\n} cuint768m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[13];\r\n} int832m_T;\r\n\r\ntypedef struct {\r\n  int832m_T re;\r\n  int832m_T im;\r\n} cint832m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[13];\r\n} uint832m_T;\r\n\r\ntypedef struct {\r\n  uint832m_T re;\r\n  uint832m_T im;\r\n} cuint832m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[14];\r\n} int896m_T;\r\n\r\ntypedef struct {\r\n  int896m_T re;\r\n  int896m_T im;\r\n} cint896m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[14];\r\n} uint896m_T;\r\n\r\ntypedef struct {\r\n  uint896m_T re;\r\n  uint896m_T im;\r\n} cuint896m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[15];\r\n} int960m_T;\r\n\r\ntypedef struct {\r\n  int960m_T re;\r\n  int960m_T im;\r\n} cint960m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[15];\r\n} uint960m_T;\r\n\r\ntypedef struct {\r\n  uint960m_T re;\r\n  uint960m_T im;\r\n} cuint960m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[16];\r\n} int1024m_T;\r\n\r\ntypedef struct {\r\n  int1024m_T re;\r\n  int1024m_T im;\r\n} cint1024m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[16];\r\n} uint1024m_T;\r\n\r\ntypedef struct {\r\n  uint1024m_T re;\r\n  uint1024m_T im;\r\n} cuint1024m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[17];\r\n} int1088m_T;\r\n\r\ntypedef struct {\r\n  int1088m_T re;\r\n  int1088m_T im;\r\n} cint1088m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[17];\r\n} uint1088m_T;\r\n\r\ntypedef struct {\r\n  uint1088m_T re;\r\n  uint1088m_T im;\r\n} cuint1088m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[18];\r\n} int1152m_T;\r\n\r\ntypedef struct {\r\n  int1152m_T re;\r\n  int1152m_T im;\r\n} cint1152m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[18];\r\n} uint1152m_T;\r\n\r\ntypedef struct {\r\n  uint1152m_T re;\r\n  uint1152m_T im;\r\n} cuint1152m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[19];\r\n} int1216m_T;\r\n\r\ntypedef struct {\r\n  int1216m_T re;\r\n  int1216m_T im;\r\n} cint1216m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[19];\r\n} uint1216m_T;\r\n\r\ntypedef struct {\r\n  uint1216m_T re;\r\n  uint1216m_T im;\r\n} cuint1216m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[20];\r\n} int1280m_T;\r\n\r\ntypedef struct {\r\n  int1280m_T re;\r\n  int1280m_T im;\r\n} cint1280m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[20];\r\n} uint1280m_T;\r\n\r\ntypedef struct {\r\n  uint1280m_T re;\r\n  uint1280m_T im;\r\n} cuint1280m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[21];\r\n} int1344m_T;\r\n\r\ntypedef struct {\r\n  int1344m_T re;\r\n  int1344m_T im;\r\n} cint1344m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[21];\r\n} uint1344m_T;\r\n\r\ntypedef struct {\r\n  uint1344m_T re;\r\n  uint1344m_T im;\r\n} cuint1344m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[22];\r\n} int1408m_T;\r\n\r\ntypedef struct {\r\n  int1408m_T re;\r\n  int1408m_T im;\r\n} cint1408m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[22];\r\n} uint1408m_T;\r\n\r\ntypedef struct {\r\n  uint1408m_T re;\r\n  uint1408m_T im;\r\n} cuint1408m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[23];\r\n} int1472m_T;\r\n\r\ntypedef struct {\r\n  int1472m_T re;\r\n  int1472m_T im;\r\n} cint1472m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[23];\r\n} uint1472m_T;\r\n\r\ntypedef struct {\r\n  uint1472m_T re;\r\n  uint1472m_T im;\r\n} cuint1472m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[24];\r\n} int1536m_T;\r\n\r\ntypedef struct {\r\n  int1536m_T re;\r\n  int1536m_T im;\r\n} cint1536m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[24];\r\n} uint1536m_T;\r\n\r\ntypedef struct {\r\n  uint1536m_T re;\r\n  uint1536m_T im;\r\n} cuint1536m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[25];\r\n} int1600m_T;\r\n\r\ntypedef struct {\r\n  int1600m_T re;\r\n  int1600m_T im;\r\n} cint1600m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[25];\r\n} uint1600m_T;\r\n\r\ntypedef struct {\r\n  uint1600m_T re;\r\n  uint1600m_T im;\r\n} cuint1600m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[26];\r\n} int1664m_T;\r\n\r\ntypedef struct {\r\n  int1664m_T re;\r\n  int1664m_T im;\r\n} cint1664m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[26];\r\n} uint1664m_T;\r\n\r\ntypedef struct {\r\n  uint1664m_T re;\r\n  uint1664m_T im;\r\n} cuint1664m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[27];\r\n} int1728m_T;\r\n\r\ntypedef struct {\r\n  int1728m_T re;\r\n  int1728m_T im;\r\n} cint1728m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[27];\r\n} uint1728m_T;\r\n\r\ntypedef struct {\r\n  uint1728m_T re;\r\n  uint1728m_T im;\r\n} cuint1728m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[28];\r\n} int1792m_T;\r\n\r\ntypedef struct {\r\n  int1792m_T re;\r\n  int1792m_T im;\r\n} cint1792m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[28];\r\n} uint1792m_T;\r\n\r\ntypedef struct {\r\n  uint1792m_T re;\r\n  uint1792m_T im;\r\n} cuint1792m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[29];\r\n} int1856m_T;\r\n\r\ntypedef struct {\r\n  int1856m_T re;\r\n  int1856m_T im;\r\n} cint1856m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[29];\r\n} uint1856m_T;\r\n\r\ntypedef struct {\r\n  uint1856m_T re;\r\n  uint1856m_T im;\r\n} cuint1856m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[30];\r\n} int1920m_T;\r\n\r\ntypedef struct {\r\n  int1920m_T re;\r\n  int1920m_T im;\r\n} cint1920m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[30];\r\n} uint1920m_T;\r\n\r\ntypedef struct {\r\n  uint1920m_T re;\r\n  uint1920m_T im;\r\n} cuint1920m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[31];\r\n} int1984m_T;\r\n\r\ntypedef struct {\r\n  int1984m_T re;\r\n  int1984m_T im;\r\n} cint1984m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[31];\r\n} uint1984m_T;\r\n\r\ntypedef struct {\r\n  uint1984m_T re;\r\n  uint1984m_T im;\r\n} cuint1984m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[32];\r\n} int2048m_T;\r\n\r\ntypedef struct {\r\n  int2048m_T re;\r\n  int2048m_T im;\r\n} cint2048m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[32];\r\n} uint2048m_T;\r\n\r\ntypedef struct {\r\n  uint2048m_T re;\r\n  uint2048m_T im;\r\n} cuint2048m_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"F:\\GitHubRepos\\bouncingball_fmu_example\\custom_bouncing_ball_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetInf.c\r\n *\r\n * Code generation for model \"custom_bouncing_ball_sf\".\r\n *\r\n * Model version              : 1.4\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue May 17 16:32:33 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finite, Inf\r\n */\r\n#include \"rtGetInf.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        inf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        inf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        minf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        minf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\bouncingball_fmu_example\\custom_bouncing_ball_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rtGetInf.h\r\n    *\r\n        * Code generation for model \"custom_bouncing_ball_sf\".\r\n    *\r\n    * Model version              : 1.4\r\n    * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n        * C source code generated on : Tue May 17 16:32:33 2022\r\n * \r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n    #ifndef RTW_HEADER_rtGetInf_h_\r\n    #define RTW_HEADER_rtGetInf_h_\r\n\r\n\r\n        \r\n\r\n    \r\n#include <stddef.h>\r\n    #include \"rtwtypes.h\"\r\n    #include \"rt_nonfinite.h\"\r\n\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n        \r\n        extern real_T rtGetInf(void);\r\n            extern real32_T rtGetInfF(void);\r\n            extern real_T rtGetMinusInf(void);\r\n            extern real32_T rtGetMinusInfF(void);\r\n        \r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    #endif /* RTW_HEADER_rtGetInf_h_ */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"F:\\GitHubRepos\\bouncingball_fmu_example\\custom_bouncing_ball_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetNaN.c\r\n *\r\n * Code generation for model \"custom_bouncing_ball_sf\".\r\n *\r\n * Model version              : 1.4\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue May 17 16:32:33 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finite, NaN\r\n */\r\n#include \"rtGetNaN.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        nan = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\r\n        tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\r\n        nan = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  uint16_T one = 1U;\r\n  enum {\r\n    LittleEndian,\r\n    BigEndian\r\n  } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n  switch (machByteOrder) {\r\n   case LittleEndian:\r\n    {\r\n      nanF.wordL.wordLuint = 0xFFC00000U;\r\n      break;\r\n    }\r\n\r\n   case BigEndian:\r\n    {\r\n      nanF.wordL.wordLuint = 0x7FFFFFFFU;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return nanF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\bouncingball_fmu_example\\custom_bouncing_ball_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rtGetNaN.h\r\n    *\r\n        * Code generation for model \"custom_bouncing_ball_sf\".\r\n    *\r\n    * Model version              : 1.4\r\n    * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n        * C source code generated on : Tue May 17 16:32:33 2022\r\n * \r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n    #ifndef RTW_HEADER_rtGetNaN_h_\r\n    #define RTW_HEADER_rtGetNaN_h_\r\n\r\n\r\n        \r\n\r\n    \r\n#include <stddef.h>\r\n    #include \"rtwtypes.h\"\r\n    #include \"rt_nonfinite.h\"\r\n\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n        \r\n        extern real_T rtGetNaN(void);\r\n            extern real32_T rtGetNaNF(void);\r\n        \r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    #endif /* RTW_HEADER_rtGetNaN_h_ */\r\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\bouncingball_fmu_example\\custom_bouncing_ball_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rt_defines.h\r\n    *\r\n        * Code generation for model \"custom_bouncing_ball_sf\".\r\n    *\r\n    * Model version              : 1.4\r\n    * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n        * C source code generated on : Tue May 17 16:32:33 2022\r\n * \r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n    #ifndef RTW_HEADER_rt_defines_h_\r\n    #define RTW_HEADER_rt_defines_h_\r\n\r\n\r\n        \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    /*===========*\r\n    * Constants *\r\n    *===========*/\r\n\r\n    #define RT_PI          3.14159265358979323846\r\n    #define RT_PIF         3.1415927F\r\n    #define RT_LN_10       2.30258509299404568402\r\n    #define RT_LN_10F      2.3025851F\r\n    #define RT_LOG10E      0.43429448190325182765\r\n    #define RT_LOG10EF     0.43429449F\r\n    #define RT_E           2.7182818284590452354\r\n    #define RT_EF          2.7182817F\r\n\r\n    /*\r\n    * UNUSED_PARAMETER(x)\r\n    *   Used to specify that a function parameter (argument) is required but not\r\n    *   accessed by the function body.\r\n    */\r\n    #ifndef UNUSED_PARAMETER\r\n    #if defined(__LCC__)\r\n    #define UNUSED_PARAMETER(x)  /* do nothing */\r\n    #else\r\n    /*\r\n    * This is the semi-ANSI standard way of indicating that an\r\n    * unused function parameter is required.\r\n    */\r\n    #define UNUSED_PARAMETER(x) (void) (x)\r\n    #endif\r\n    #endif\r\n\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    #endif /* RTW_HEADER_rt_defines_h_ */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"F:\\GitHubRepos\\bouncingball_fmu_example\\custom_bouncing_ball_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rt_nonfinite.c\r\n *\r\n * Code generation for model \"custom_bouncing_ball_sf\".\r\n *\r\n * Model version              : 1.4\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue May 17 16:32:33 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finites,\r\n *      (Inf, NaN and -Inf).\r\n */\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\bouncingball_fmu_example\\custom_bouncing_ball_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rt_nonfinite.h\r\n    *\r\n        * Code generation for model \"custom_bouncing_ball_sf\".\r\n    *\r\n    * Model version              : 1.4\r\n    * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n        * C source code generated on : Tue May 17 16:32:33 2022\r\n * \r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n    #ifndef RTW_HEADER_rt_nonfinite_h_\r\n    #define RTW_HEADER_rt_nonfinite_h_\r\n\r\n\r\n        \r\n\r\n    \r\n#include <stddef.h>\r\n    #include \"rtwtypes.h\"\r\n\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n        \r\n    \r\n\r\n\r\n    extern real_T rtInf;\r\n\r\n\r\n    \r\n\r\n\r\n    extern real_T rtMinusInf;\r\n\r\n\r\n    \r\n\r\n\r\n    extern real_T rtNaN;\r\n\r\n\r\n    \r\n\r\n\r\n    extern real32_T rtInfF;\r\n\r\n\r\n    \r\n\r\n\r\n    extern real32_T rtMinusInfF;\r\n\r\n\r\n    \r\n\r\n\r\n    extern real32_T rtNaNF;\r\n\r\n\r\n\r\n        extern void rt_InitInfAndNaN(size_t realSize);\r\n            extern boolean_T rtIsInf(real_T value);\r\n            extern boolean_T rtIsInfF(real32_T value);\r\n            extern boolean_T rtIsNaN(real_T value);\r\n            extern boolean_T rtIsNaNF(real32_T value);\r\n    \r\n    typedef struct  {\r\n    struct {\r\n        uint32_T wordH;\r\n        uint32_T wordL;\r\n    } words;\r\n    } BigEndianIEEEDouble;\r\n\r\n    typedef struct  {\r\n    struct {\r\n        uint32_T wordL;\r\n        uint32_T wordH;\r\n    } words;\r\n    } LittleEndianIEEEDouble;\r\n\r\n    typedef struct  {\r\n    union {\r\n        real32_T wordLreal;\r\n        uint32_T wordLuint;\r\n    } wordL;\r\n    } IEEESingle;\r\n\r\n    \r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    #endif /* RTW_HEADER_rt_nonfinite_h_ */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\bouncingball_fmu_example\\custom_bouncing_ball_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtwtypes.h\r\n *\r\n * Code generation for model \"custom_bouncing_ball_sf\".\r\n *\r\n * Model version              : 1.4\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue May 17 16:32:33 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n#include \"tmwtypes.h\"\r\n#ifndef POINTER_T\r\n#define POINTER_T\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n#ifndef INT64_T\r\n#define INT64_T\r\n\r\ntypedef long long int64_T;\r\n\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#endif\r\n\r\n#ifndef UINT64_T\r\n#define UINT64_T\r\n\r\ntypedef unsigned long long uint64_T;\r\n\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n#endif\r\n\r\n/*===========================================================================*\r\n * Additional complex number type definitions                                           *\r\n *===========================================================================*/\r\n#ifndef CINT64_T\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#endif\r\n\r\n#ifndef CUINT64_T\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n#endif\r\n#endif                                 /* RTWTYPES_H */\r\n"},{"name":"custom_bouncing_ball_mid.h","type":"header","group":"interface","path":"F:\\GitHubRepos\\bouncingball_fmu_example\\custom_bouncing_ball_sfcn_rtw_fmi","tag":"","groupDisplay":"Interface files","code":"/*\r\n * custom_bouncing_ball_mid.h\r\n *\r\n * Code generation for model \"custom_bouncing_ball_sf\".\r\n *\r\n * Model version              : 1.4\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue May 17 16:32:33 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n *\r\n * SOURCES: custom_bouncing_ball_sf.c\r\n */\r\n\r\n#include \"simstruc.h\"\r\n#include \"custom_bouncing_ball_sf.h\"\r\n#if defined(MATLAB_MEX_FILE) || defined(RT_MALLOC)\r\n\r\nstatic int_T RegNumInputPorts(SimStruct *S, int_T nInputPorts)\r\n{\r\n  _ssSetNumInputPorts(S,nInputPorts);\r\n  return true;\r\n}\r\n\r\nstatic int_T RegNumOutputPorts(SimStruct *S, int_T nOutputPorts)\r\n{\r\n  _ssSetNumOutputPorts(S,nOutputPorts);\r\n  return true;\r\n}\r\n\r\nstatic int_T FcnSetErrorStatus(const SimStruct *S, DTypeId arg2)\r\n{\r\n  static char msg[256];\r\n  if (strlen(ssGetModelName(S)) < 128) {\r\n    sprintf(msg,\r\n            \"S-function %s does not have a tlc file. It cannot use macros that access regDataType field in simstruct.\",\r\n            ssGetModelName(S));\r\n  } else {\r\n    sprintf(msg,\r\n            \"A S-function does not have a tlc file. It cannot use macros that access regDataType field in simstruct.\");\r\n  }\r\n\r\n  ssSetErrorStatus(S, msg);\r\n  UNUSED_PARAMETER(arg2);\r\n  return 0;\r\n}\r\n\r\nstatic void * FcnSetErrorStatusWithReturnPtr(const SimStruct *S, DTypeId arg2)\r\n{\r\n  FcnSetErrorStatus(S,0);\r\n  UNUSED_PARAMETER(arg2);\r\n  return 0;\r\n}\r\n\r\nstatic int_T FcnSetErrorStatusWithArgPtr(const SimStruct *S, const void* arg2)\r\n{\r\n  FcnSetErrorStatus(S,0);\r\n  UNUSED_PARAMETER(arg2);\r\n  return 0;\r\n}\r\n\r\n#endif\r\n\r\n/* Instance data for model: custom_bouncing_ball */\r\nvoid *custom_bouncing_ball_malloc(SimStruct *rts)\r\n{\r\n  /* Local SimStruct for the generated S-Function */\r\n  LocalS *lS = (LocalS *) malloc(sizeof(LocalS));\r\n  ss_VALIDATE_MEMORY(rts,lS);\r\n  (void) memset((char *) lS, 0,\r\n                sizeof(LocalS));\r\n  ssSetUserData(rts, lS);\r\n\r\n  /* block I/O */\r\n  {\r\n    void *b = malloc(sizeof(B_custom_bouncing_ball_T));\r\n    ss_VALIDATE_MEMORY(rts,b);\r\n    ssSetLocalBlockIO(rts, b);\r\n    (void) memset(b, 0,\r\n                  sizeof(B_custom_bouncing_ball_T));\r\n  }\r\n\r\n  /* model parameters */\r\n  ssSetLocalDefaultParam(rts, (real_T *) &custom_bouncing_ball_DefaultP);\r\n\r\n  /* model checksums */\r\n  ssSetChecksumVal(rts, 0, 4157450820U);\r\n  ssSetChecksumVal(rts, 1, 518106736U);\r\n  ssSetChecksumVal(rts, 2, 3939282046U);\r\n  ssSetChecksumVal(rts, 3, 3211457660U);\r\n  return (NULL);\r\n}\r\n"},{"name":"custom_bouncing_ball_sid.h","type":"header","group":"interface","path":"F:\\GitHubRepos\\bouncingball_fmu_example\\custom_bouncing_ball_sfcn_rtw_fmi","tag":"","groupDisplay":"Interface files","code":"/*\r\n * custom_bouncing_ball_sid.h\r\n *\r\n * Code generation for model \"custom_bouncing_ball_sf\".\r\n *\r\n * Model version              : 1.4\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue May 17 16:32:33 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n *\r\n * SOURCES: custom_bouncing_ball_sf.c\r\n */\r\n\r\n/* statically allocated instance data for model: custom_bouncing_ball */\r\n{\r\n  extern P_custom_bouncing_ball_T custom_bouncing_ball_DefaultP;\r\n\r\n  {\r\n    /* Local SimStruct for the generated S-Function */\r\n    static LocalS slS;\r\n    LocalS *lS = &slS;\r\n    ssSetUserData(rts, lS);\r\n\r\n    /* block I/O */\r\n    {\r\n      static B_custom_bouncing_ball_T sfcnB;\r\n      void *b = (real_T *) &sfcnB;\r\n      ssSetLocalBlockIO(rts, b);\r\n      (void) memset(b, 0,\r\n                    sizeof(B_custom_bouncing_ball_T));\r\n    }\r\n\r\n    /* model parameters */\r\n    ssSetLocalDefaultParam(rts, (real_T *) &custom_bouncing_ball_DefaultP);\r\n\r\n    /* model checksums */\r\n    ssSetChecksumVal(rts, 0, 4157450820U);\r\n    ssSetChecksumVal(rts, 1, 518106736U);\r\n    ssSetChecksumVal(rts, 2, 3939282046U);\r\n    ssSetChecksumVal(rts, 3, 3211457660U);\r\n  }\r\n}\r\n"},{"name":"ode3.c","type":"source","group":"legacy","path":"D:\\Program Files\\Matlab\\rtw\\c\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2009 The MathWorks, Inc.\n *\n * File: ode3.c        \n *\n */\n\n#include <math.h>\n#include <string.h>\n#include \"tmwtypes.h\"\n#ifdef USE_RTMODEL\n# include \"simstruc_types.h\"\n#else\n# include \"simstruc.h\"\n#endif\n#include \"odesup.h\"\n\nstatic const real_T rt_ODE3_A[3] = {\n    1.0/2.0, 3.0/4.0, 1.0\n};\n\nstatic const real_T rt_ODE3_B[3][3] = {\n    { 1.0/2.0,     0.0,     0.0 },\n    {     0.0, 3.0/4.0,     0.0 },\n    { 2.0/9.0, 1.0/3.0, 4.0/9.0 }\n};\n\n\ntypedef struct IntgData_tag {\n    real_T *y;\n    real_T *f[3];\n} IntgData;\n\n\n#ifndef RT_MALLOC\n  /* statically declare data */\n  static real_T   rt_ODE3_Y[NCSTATES];\n  static real_T   rt_ODE3_F[3][NCSTATES];\n  static IntgData rt_ODE3_IntgData = {rt_ODE3_Y,\n                                      {rt_ODE3_F[0],rt_ODE3_F[1],rt_ODE3_F[2]}};\n\nvoid rt_ODECreateIntegrationData(RTWSolverInfo *si)\n  {\n      rtsiSetSolverData(si,(void *)&rt_ODE3_IntgData);\n      rtsiSetSolverName(si,\"ode3\");\n  }\n#else\n  /* dynamically allocated data */\n\n  void rt_ODECreateIntegrationData(RTWSolverInfo *si)\n  {\n      IntgData *id = (IntgData *) malloc(sizeof(IntgData));\n      if(id == NULL) {\n          rtsiSetErrorStatus(si, RT_MEMORY_ALLOCATION_ERROR);\n          return;\n      }\n      \n      id->y = (real_T *) malloc(4*rtsiGetNumContStates(si) * sizeof(real_T));\n      if(id->y == NULL) {\n          rtsiSetErrorStatus(si, RT_MEMORY_ALLOCATION_ERROR);\n          return;\n      }\n      id->f[0] = id->y + rtsiGetNumContStates(si);\n      id->f[1] = id->f[0] + rtsiGetNumContStates(si);\n      id->f[2] = id->f[1] + rtsiGetNumContStates(si);\n      \n      rtsiSetSolverData(si, (void *)id);\n      rtsiSetSolverName(si,\"ode3\");\n  }\n\n  void rt_ODEDestroyIntegrationData(RTWSolverInfo *si)\n  {\n      IntgData *id = rtsiGetSolverData(si);\n      \n      if (id != NULL) {\n          if (id->y != NULL) {\n              free(id->y);\n          }\n          free(id);\n          rtsiSetSolverData(si, NULL);\n      }\n  }\n#endif\n\nvoid rt_ODEUpdateContinuousStates(RTWSolverInfo *si)\n{\n    time_T    t          = rtsiGetT(si);\n    time_T    tnew       = rtsiGetSolverStopTime(si);\n    time_T    h          = rtsiGetStepSize(si);\n    real_T    *x         = rtsiGetContStates(si);\n    IntgData  *id        = rtsiGetSolverData(si);\n    real_T    *y         = id->y;\n    real_T    *f0        = id->f[0];\n    real_T    *f1        = id->f[1];\n    real_T    *f2        = id->f[2];\n    real_T    hB[3];\n    int_T     i;\n\n#ifdef NCSTATES\n    int_T     nXc        = NCSTATES;\n#else\n    int_T     nXc        = rtsiGetNumContStates(si);\n#endif\n\n    rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\n\n    /* Save the state values at time t in y, we'll use x as ynew. */\n    (void)memcpy(y, x, nXc*sizeof(real_T));\n\n    /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\n    /* f0 = f(t,y) */\n    rtsiSetdX(si, f0);\n    DERIVATIVES(si);\n\n    /* f(:,2) = feval(odefile, t + hA(1), y + f*hB(:,1), args(:)(*)); */\n    hB[0] = h * rt_ODE3_B[0][0];\n    for (i = 0; i < nXc; i++) {\n\tx[i] = y[i] + (f0[i]*hB[0]);\n    }\n    rtsiSetT(si, t + h*rt_ODE3_A[0]);\n    rtsiSetdX(si, f1);\n    OUTPUTS(si,0);\n    DERIVATIVES(si);\n\n    /* f(:,3) = feval(odefile, t + hA(2), y + f*hB(:,2), args(:)(*)); */\n    for (i = 0; i <= 1; i++) hB[i] = h * rt_ODE3_B[1][i];\n    for (i = 0; i < nXc; i++) {\n\tx[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1]);\n    }\n    rtsiSetT(si, t + h*rt_ODE3_A[1]);\n    rtsiSetdX(si, f2);\n    OUTPUTS(si,0);\n    DERIVATIVES(si);\n\n    /* tnew = t + hA(3);\n       ynew = y + f*hB(:,3); */\n    for (i = 0; i <= 2; i++) hB[i] = h * rt_ODE3_B[2][i];\n    for (i = 0; i < nXc; i++) {\n\tx[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2]);\n    }\n    rtsiSetT(si, tnew);\n\n    PROJECTION(si);\n    REDUCTION(si);\n\n    rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\n}\n\n\n/* [EOF] ode3.c */\n"},{"name":"sfcn_fmi.h","type":"header","group":"other","path":"F:\\GitHubRepos\\bouncingball_fmu_example\\custom_bouncing_ball_sfcn_rtw_fmi","tag":"","groupDisplay":"Other files","code":"/*\r\n * sfcn_fmi.h\r\n *\r\n *  Model-specific code required to build FMI executable\r\n *  from Simulink model \"custom_bouncing_ball\".\r\n *\r\n * Generated on : Tue May 17 16:32:33 2022\r\n */\r\n\r\n#ifndef SFCN_FMI_H\r\n#define SFCN_FMI_H\r\n\r\n/* Include header for FMI 2.0 */\r\n#include \"fmi/fmi2Functions.h\"\r\n\r\n/* Define GUID string */\r\nchar* GUIDString = \"{ad0c31c0-9103-4715-bccc-269e4f609958}\";\r\n\r\n#if defined(MATLAB_MEX_FILE)\r\n#define mexCallMATLAB                  sfcn_fmi_load_mexw64\r\n#else\r\n\r\n/* Code to enable global tunable parameters in stand-alone mode */\r\n#define RTW_GENERATED_SFCN_TUNABLE_PRMS_custom_bouncing_ball_sf\r\n#define RTW_GENERATED_S_FUNCTION\r\n#include \"simstruc.h\"\r\n#include \"fixedpoint.h\"\r\n#if defined (_MSC_VER)\r\n\r\n#pragma warning(disable:4005)\r\n\r\n#endif\r\n\r\n#define mxGetData(x)                   x\r\n#define g(S)                           &(((P_custom_bouncing_ball_T *) ssGetLocalDefaultParam(S))->g)\r\n#define r(S)                           &(((P_custom_bouncing_ball_T *) ssGetLocalDefaultParam(S))->r)\r\n#define v(S)                           &(((P_custom_bouncing_ball_T *) ssGetLocalDefaultParam(S))->v)\r\n#define ssFxpSetU32BitRegionCompliant(S, v)\r\n#include \"rt_nonfinite.c\"\r\n#endif\r\n\r\n/* Include Simulink Coder-generated model code */\r\n#include \"custom_bouncing_ball_sf.c\"\r\n\r\n/* Solver settings selected in Simulink */\r\nint_T SFCN_FMI_IS_VARIABLE_STEP_SOLVER = 0;\r\nreal_T SFCN_FMI_FIXED_STEP_SIZE = 0.2;\r\nint_T SFCN_FMI_IS_MT = 0;\r\nint_T SFCN_FMI_EXTRAPOLATION_ORDER = -1;\r\nint_T SFCN_FMI_NEWTON_ITER = -1;\r\n\r\n/* Model sizes */\r\nint_T SFCN_FMI_ZC_LENGTH = 0;\r\nint_T SFCN_FMI_NBR_INPUTS = 0;\r\nint_T SFCN_FMI_NBR_OUTPUTS = 2;\r\nint_T SFCN_FMI_NBR_PARAMS = 0;\r\nint_T SFCN_FMI_NBR_BLOCKIO = 0;\r\nint_T SFCN_FMI_NBR_DWORK = 0;\r\n\r\n/* Model identifier */\r\nchar* SFCN_FMI_MODEL_IDENTIFIER = \"custom_bouncing_ball_sf\";\r\n\r\n/* Loading of MEX binaries, path to MATLAB bin */\r\nint_T SFCN_FMI_LOAD_MEX = 1;\r\nconst char* SFCN_FMI_MATLAB_BIN = \"D:\\\\Program Files\\\\Matlab\\\\bin\\\\win64\";\r\nint_T SFCN_FMI_NBR_MEX = 0;\r\nchar* SFCN_FMI_MEX_NAMES[1] = { \"\" };\r\n\r\n/* Register model callback routines in SimStruct */\r\nvoid sfcn_fmi_registerMdlCallbacks_(SimStruct*S)\r\n{\r\n  ssSetmdlInitializeSizes(S, mdlInitializeSizes);\r\n  ssSetmdlInitializeSampleTimes(S, mdlInitializeSampleTimes);\r\n\r\n#if defined(MDL_INITIALIZE_CONDITIONS)\r\n\r\n  ssSetmdlInitializeConditions(S, mdlInitializeConditions);\r\n\r\n#else\r\n\r\n  ssSetmdlInitializeConditions(S, NULL);\r\n\r\n#endif\r\n\r\n#if defined(MDL_START)\r\n\r\n  ssSetmdlStart(S, mdlStart);\r\n\r\n#else\r\n\r\n  ssSetmdlStart(S, NULL);\r\n\r\n#endif\r\n\r\n#if defined(RTW_GENERATED_ENABLE)\r\n\r\n  _ssSetRTWGeneratedEnable(S, mdlEnable);\r\n\r\n#else\r\n\r\n  _ssSetRTWGeneratedEnable(S, NULL);\r\n\r\n#endif\r\n\r\n  ssSetmdlOutputs(S,mdlOutputs);\r\n\r\n#if defined(MDL_ZERO_CROSSINGS)\r\n\r\n  ssSetmdlZeroCrossings(S, mdlZeroCrossings);\r\n\r\n#else\r\n\r\n  ssSetmdlZeroCrossings(S, NULL);\r\n\r\n#endif\r\n\r\n#if defined(MDL_DERIVATIVES)\r\n\r\n  ssSetmdlDerivatives(S, mdlDerivatives);\r\n\r\n#else\r\n\r\n  ssSetmdlDerivatives(S, NULL);\r\n\r\n#endif\r\n\r\n#if defined (MDL_UPDATE)\r\n\r\n  ssSetmdlUpdate(S, mdlUpdate);\r\n\r\n#else\r\n\r\n  ssSetmdlUpdate(S, NULL);\r\n\r\n#endif\r\n\r\n  ssSetmdlTerminate(S, mdlTerminate);\r\n}\r\n\r\n/* Register SolverInfo model method pointers */\r\nextern void mdlNoOpFunc(SimStruct* S);\r\nvoid sfcn_fmi_registerRTModelCallbacks_(SimStruct*S)\r\n{\r\n\r\n#if defined(MDL_DERIVATIVES)\r\n\r\n  S->mdlInfo->solverInfo->modelMethodsPtr->rtmDervisFcn = (rtMdlDerivativesFcn)\r\n    mdlDerivatives;\r\n\r\n#else\r\n\r\n  S->mdlInfo->solverInfo->modelMethodsPtr->rtmDervisFcn = (rtMdlProjectionFcn)\r\n    mdlNoOpFunc;\r\n\r\n#endif\r\n\r\n  S->mdlInfo->solverInfo->modelMethodsPtr->rtmProjectionFcn =\r\n    (rtMdlProjectionFcn) mdlNoOpFunc;\r\n  S->mdlInfo->solverInfo->modelMethodsPtr->rtmOutputsFcn = (rtMdlOutputsFcn)\r\n    mdlOutputs;\r\n}\r\n\r\n/* Pointers to input variables */\r\nvoid sfcn_fmi_assignInputs_(SimStruct* S, void** inputs)\r\n{\r\n  return;                              /* No inputs */\r\n}\r\n\r\n/* Pointers to output variables */\r\nvoid sfcn_fmi_assignOutputs_(SimStruct* S, void** outputs)\r\n{\r\n  outputs[0] = &(((real_T *) ssGetOutputPortSignal(S, 0))[0]);\r\n  outputs[1] = &(((real_T *) ssGetOutputPortSignal(S, 1))[0]);\r\n}\r\n\r\n/* Pointers to model parameters */\r\nvoid sfcn_fmi_assignParameters_(SimStruct* S, void** parameters)\r\n{\r\n  return;                /* No parameters in model (probably due to inlining) */\r\n}\r\n\r\n/* Copy parameter values to S-function mxArrays */\r\nvoid sfcn_fmi_copyToSFcnParams_(SimStruct* S)\r\n{\r\n  return;                /* No parameters in model (probably due to inlining) */\r\n}\r\n\r\n/* Return pointer to parameter struct in UserData */\r\nvoid* sfcn_fmi_getParametersP_(SimStruct* S)\r\n{\r\n  return 0;\r\n}\r\n\r\n/* Handle mxArrays for global tunable parameters */\r\nvoid sfcn_fmi_mxGlobalTunable_(SimStruct* S, int_T create, int_T update)\r\n{\r\n  mxArray *param;\r\n  int_T i;\r\n  if (create && !update) {\r\n    S->sfcnParams.dlgParams = (mxArray**) allocateMemory0(3, sizeof(mxArray*));\r\n  }\r\n\r\n  if (create) {\r\n    {\r\n      real_T *vals0;\r\n      if (update) {\r\n        param = _ssGetSFcnParam(S, 0);\r\n        vals0 = (real_T *) &(((P_custom_bouncing_ball_T *)\r\n                              ssGetLocalDefaultParam(S))->g);\r\n      } else {\r\n        param = mxCreateNumericMatrix(1, 1, mxDOUBLE_CLASS, mxREAL);\r\n        mexMakeArrayPersistent(param);\r\n        _ssSetSFcnParam(S, 0, param);\r\n        vals0 = (real_T *) &(custom_bouncing_ball_DefaultP.g);\r\n      }\r\n\r\n      for (i=0;i< 1 * 1;i++) {\r\n        ((real_T*)mxGetData(param))[i] = vals0[i];\r\n      }\r\n    }\r\n  } else {\r\n    mxDestroyArray(_ssGetSFcnParam(S, 0));\r\n  }\r\n\r\n  if (create) {\r\n    {\r\n      real_T *vals1;\r\n      if (update) {\r\n        param = _ssGetSFcnParam(S, 1);\r\n        vals1 = (real_T *) &(((P_custom_bouncing_ball_T *)\r\n                              ssGetLocalDefaultParam(S))->r);\r\n      } else {\r\n        param = mxCreateNumericMatrix(1, 1, mxDOUBLE_CLASS, mxREAL);\r\n        mexMakeArrayPersistent(param);\r\n        _ssSetSFcnParam(S, 1, param);\r\n        vals1 = (real_T *) &(custom_bouncing_ball_DefaultP.r);\r\n      }\r\n\r\n      for (i=0;i< 1 * 1;i++) {\r\n        ((real_T*)mxGetData(param))[i] = vals1[i];\r\n      }\r\n    }\r\n  } else {\r\n    mxDestroyArray(_ssGetSFcnParam(S, 1));\r\n  }\r\n\r\n  if (create) {\r\n    {\r\n      real_T *vals2;\r\n      if (update) {\r\n        param = _ssGetSFcnParam(S, 2);\r\n        vals2 = (real_T *) &(((P_custom_bouncing_ball_T *)\r\n                              ssGetLocalDefaultParam(S))->v);\r\n      } else {\r\n        param = mxCreateNumericMatrix(1, 1, mxDOUBLE_CLASS, mxREAL);\r\n        mexMakeArrayPersistent(param);\r\n        _ssSetSFcnParam(S, 2, param);\r\n        vals2 = (real_T *) &(custom_bouncing_ball_DefaultP.v);\r\n      }\r\n\r\n      for (i=0;i< 1 * 1;i++) {\r\n        ((real_T*)mxGetData(param))[i] = vals2[i];\r\n      }\r\n    }\r\n  } else {\r\n    mxDestroyArray(_ssGetSFcnParam(S, 2));\r\n  }\r\n}\r\n\r\n/* Pointers to block output variables */\r\nvoid sfcn_fmi_assignBlockOutputs_(SimStruct* S, void** blockoutputs)\r\n{\r\n  return;                              /* No global block outputs */\r\n}\r\n\r\n/* Pointers to DWork variables for discrete states */\r\nvoid sfcn_fmi_assignDWork_(SimStruct* S, void** dwork)\r\n{\r\n  return;                           /* No DWork variables for discrete states */\r\n}\r\n\r\n/* Sizes of bus I/O structs for allocation in FMU */\r\nvoid* sfcn_fmi_allocateBusObject(int_T isInput, int_T portid, int_T width)\r\n{\r\n  return 0;\r\n}\r\n\r\n#if !defined(MATLAB_MEX_FILE)\r\n\r\nint_T _ssSetInputPortMatrixDimensions(SimStruct *S, int_T port, int_T m, int_T n)\r\n{\r\n  extern int_T _ssSetInputPortMatrixDimensions_FMI(SimStruct *S, int_T port,\r\n    int_T m, int_T n);\r\n  return _ssSetInputPortMatrixDimensions_FMI(S, port, m, n);\r\n}\r\n\r\nint_T _ssSetOutputPortMatrixDimensions(SimStruct *S, int_T port, int_T m, int_T\r\n  n)\r\n{\r\n  extern int_T _ssSetOutputPortMatrixDimensions_FMI(SimStruct *S, int_T port,\r\n    int_T m, int_T n);\r\n  return _ssSetOutputPortMatrixDimensions_FMI(S, port, m, n);\r\n}\r\n\r\nint_T _ssSetInputPortVectorDimension(SimStruct *S, int_T port, int_T m)\r\n{\r\n  extern int_T _ssSetInputPortVectorDimension_FMI(SimStruct *S, int_T port,\r\n    int_T m);\r\n  return _ssSetInputPortVectorDimension_FMI(S, port, m);\r\n}\r\n\r\nint_T _ssSetOutputPortVectorDimension(SimStruct *S, int_T port, int_T m)\r\n{\r\n  extern int_T _ssSetOutputPortVectorDimension_FMI(SimStruct *S, int_T port,\r\n    int_T m);\r\n  return _ssSetOutputPortVectorDimension_FMI(S, port, m);\r\n}\r\n\r\n#endif\r\n#endif\r\n"},{"name":"sfcn_fmi_rel_conf.h","type":"header","group":"other","path":"F:\\GitHubRepos\\bouncingball_fmu_example\\custom_bouncing_ball_sfcn_rtw_fmi","tag":"","groupDisplay":"Other files","code":"/*\r\n * sfcn_fmi_rel_conf.h\r\n *\r\n *  Defines to configure MATLAB release for compilation.\r\n *  Can be adapted manually for source code FMUs.\r\n *\r\n *  Generated from Simulink model \"custom_bouncing_ball\".\r\n *\r\n * Generated on : Tue May 17 16:32:33 2022\r\n */\r\n\r\n#ifndef SFCN_FMI_REL_CONF_H\r\n#define SFCN_FMI_REL_CONF_H\r\n\r\n/*\r\n * Set one of these defines depending on MATLAB release:\r\n *\r\n * MATLAB_R2011a_ : Define this for compilation with R2011a - R2014b\r\n * MATLAB_R2015a_ : Define this for compilation with R2015a - R2017a\r\n * MATLAB_R2017b_ : Define this for compilation with R2017b - R2018b\r\n *\r\n * No define needed for R2010a - R2010b.\r\n *\r\n */\r\n#define MATLAB_R2017b_\r\n#endif\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};